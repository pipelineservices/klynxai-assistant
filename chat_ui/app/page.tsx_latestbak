"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";

/* ---------------- Types ---------------- */

type Role = "user" | "assistant";

type Message = {
  role: Role;
  content: string;
};

type ChatSession = {
  id: string;
  title: string;
  messages: Message[];
};

const STORAGE_KEY = "klynx_chat_sessions";

/* ---------------- Utils ---------------- */

function safeUUID(): string {
  try {
    const c: any = typeof crypto !== "undefined" ? crypto : undefined;
    if (c?.randomUUID) return c.randomUUID();
  } catch {}
  return `id_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
}

/* ---------------- Page ---------------- */

export default function Page() {
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [activeId, setActiveId] = useState("");
  const [input, setInput] = useState("");
  const [streaming, setStreaming] = useState(false);

  const scrollRef = useRef<HTMLDivElement>(null);
  const sessionsRef = useRef<ChatSession[]>([]);
  const activeIdRef = useRef("");
  const abortRef = useRef<AbortController | null>(null);

  useEffect(() => { sessionsRef.current = sessions; }, [sessions]);
  useEffect(() => { activeIdRef.current = activeId; }, [activeId]);

  /* ---------- Load ---------- */
  useEffect(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed) && parsed.length) {
          setSessions(parsed);
          setActiveId(parsed[0].id);
          return;
        }
      }
    } catch {}

    const first: ChatSession = { id: safeUUID(), title: "Hello", messages: [] };
    setSessions([first]);
    setActiveId(first.id);
  }, []);

  /* ---------- Persist ---------- */
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions));
  }, [sessions]);

  /* ---------- Scroll ---------- */
  useEffect(() => {
    scrollRef.current?.scrollTo({
      top: scrollRef.current.scrollHeight,
      behavior: "smooth",
    });
  }, [sessions, activeId, streaming]);

  const active = useMemo(
    () => sessions.find((s) => s.id === activeId),
    [sessions, activeId]
  );

  /* ---------- Helpers ---------- */

  function copyText(text: string) {
    navigator.clipboard.writeText(text).catch(() => {});
  }

  function stopStreaming() {
    abortRef.current?.abort();
    abortRef.current = null;
    setStreaming(false);
  }

  function regenerate(index: number) {
    if (!active) return;
    for (let i = index - 1; i >= 0; i--) {
      if (active.messages[i].role === "user") {
        setInput(active.messages[i].content);
        setTimeout(send, 0);
        return;
      }
    }
  }

  function deleteChat(id: string) {
    setSessions((prev) => {
      const next = prev.filter((s) => s.id !== id);
      if (id === activeIdRef.current) {
        if (next.length) setActiveId(next[0].id);
        else {
          const first: ChatSession = { id: safeUUID(), title: "Hello", messages: [] };
          setActiveId(first.id);
          return [first];
        }
      }
      return next;
    });
  }

  /* ---------- Send ---------- */

  async function send() {
    const text = input.trim();
    if (!text || streaming || !active) return;

    setInput("");
    setStreaming(true);

    const controller = new AbortController();
    abortRef.current = controller;

    const userMsg: Message = { role: "user", content: text };

    setSessions((prev) =>
      prev.map((s) =>
        s.id === activeId
          ? {
              ...s,
              title: s.messages.length === 0 ? text.slice(0, 32) : s.title,
              messages: [...s.messages, userMsg, { role: "assistant", content: "" }],
            }
          : s
      )
    );

    try {
      const res = await fetch("/api/chat/stream", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages: [...active.messages, userMsg] }),
        signal: controller.signal,
      });

      if (!res.body) throw new Error("No stream");

      const reader = res.body.getReader();
      const decoder = new TextDecoder();

      let buffer = "";
      let pending = "";

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        pending += decoder.decode(value, { stream: true });
        const lines = pending.split("\n");
        pending = lines.pop() || "";

        for (const line of lines) {
          if (!line.startsWith("data:")) continue;
          const chunk = line.replace(/^data:\s*/, "");
          if (chunk === "[DONE]") break;

          buffer += chunk;

          setSessions((prev) =>
            prev.map((s) => {
              if (s.id !== activeId) return s;
              const msgs = [...s.messages];
              msgs[msgs.length - 1] = { role: "assistant", content: buffer };
              return { ...s, messages: msgs };
            })
          );
        }
      }
    } catch (e: any) {
      if (e?.name !== "AbortError") console.error(e);
    } finally {
      abortRef.current = null;
      setStreaming(false);
    }
  }

  /* ---------- UI ---------- */

  return (
    <div style={{ display: "flex", height: "100vh", fontFamily: "system-ui" }}>
      {/* Sidebar */}
      <aside style={{ width: 240, borderRight: "1px solid #ddd", padding: 12 }}>
        <button
          onClick={() => {
            const id = safeUUID();
            setSessions((p) => [{ id, title: "New chat", messages: [] }, ...p]);
            setActiveId(id);
          }}
        >
          + New chat
        </button>

        {sessions.map((s) => (
          <div
            key={s.id}
            onClick={() => setActiveId(s.id)}
            style={{
              marginTop: 10,
              padding: 10,
              borderRadius: 8,
              background: s.id === activeId ? "#e7f0ff" : "transparent",
              display: "flex",
              justifyContent: "space-between",
              cursor: "pointer",
            }}
          >
            <span>{s.title}</span>
            <button
              onClick={(e) => {
                e.stopPropagation();
                deleteChat(s.id);
              }}
              style={{ border: "none", background: "transparent", cursor: "pointer" }}
            >
              üóë
            </button>
          </div>
        ))}
      </aside>

      {/* Chat */}
      <main style={{ flex: 1, display: "flex", flexDirection: "column" }}>
        <div ref={scrollRef} style={{ flex: 1, overflowY: "auto", padding: 16 }}>
          {active?.messages.map((m, i) => (
            <div
              key={i}
              style={{
                marginBottom: 12,
                padding: 12,
                borderRadius: 10,
                background: m.role === "user" ? "#e7f0ff" : "#f0f0f0",
              }}
            >
              {m.role === "assistant" ? (
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {m.content}
                </ReactMarkdown>
              ) : (
                <span>{m.content}</span>
              )}

              {m.role === "assistant" && (
                <div style={{ marginTop: 6 }}>
                  <button onClick={() => copyText(m.content)}>üìã</button>
                  <button onClick={() => regenerate(i)}>üîÑ</button>
                  {streaming && i === active.messages.length - 1 && (
                    <button onClick={stopStreaming}>‚èπ</button>
                  )}
                </div>
              )}

              {streaming &&
                i === active.messages.length - 1 &&
                m.role === "assistant" && <span>‚ñç</span>}
            </div>
          ))}
        </div>

        <div style={{ padding: 12, borderTop: "1px solid #ddd" }}>
          <textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                send();
              }
            }}
            placeholder="Message KLYNX..."
            rows={2}
            style={{ width: "100%" }}
          />
          <button onClick={send} disabled={streaming}>
            Send
          </button>
        </div>
      </main>
    </div>
  );
}

